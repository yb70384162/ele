1、fastclick
 原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
缺点: 脚本相对较大
在vue中使用???
?```js? ??// 安装? ?
 npm install fastclick -S? ? // 引入? ? 
import FastClick from 'fastclick'? ? // 使用? ? FastClick.attach(document.body);? ? ```
2、js刷新页面location.reload()用法
注意：
window.location.reload;
刷新时如果提交数据的动作，则会出现对话框！
解决
代码示例:
window.location.href=window.location.href; 
window.location.reload;
router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：在APP.js中，
https://www.jianshu.com/p/0b0222954483
// routes 配置
export default [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/:id',
    name: 'edit',
    component: Edit,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]
3.Ajax请求中的async:false/true的作用
async. 默认是true，即为异步方式，$.Ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发$.Ajax里的success方法，这时候执行的是两个线程。若要将其设置为false，则所有的请求均为同步请求，在没有返回值之前，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
var temp;
  $.ajax({
  
     async: false,
     type : "POST",
     url : defaultPostData.url,
     dataType : 'json',
     success : function(data) 
     {
 
      temp=data; 
   }
 
 });
 
alert(temp);
这个ajax请求为同步请求，在没有返回值之前，alert(temp)是不会执行的。

如果async设置为：true，则不会等待ajax请求返回的结果，会直接执行ajax后面的语句

4、讲讲vue路由懒加载
const tvProgram = resolve => require(['路由'], resolve);
require-ensure和require-amd的区别：     
require-amd?
说明: 同AMD规范的require函数，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数
语法:?require(dependencies: String[], [callback: function(...)])
参数?
dependencies: 模块依赖数组
callback: 回调函数

require-ensure?
说明: require.ensure在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。require.ensure会创建一个chunk，且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。
语法:?require.ensure(dependencies: String[], callback: function([require]), [chunkName: String])?
dependencies: 依赖的模块数组
callback: 回调函数，该函数调用时会传一个require参数
chunkName: 模块名，用于构建时生成文件时命名使用
注意点：requi.ensure的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。
--------------------- 
5、mixins混合对象的使用

对mixins的理解，有点像注册了一个vue的公共方法，可以绑定在多个组件或者多个Vue对象实例中使用。另一点，类似于在原型对象中注册方法，实例对象即组件或者Vue实例对象中，仍然可以定义相同函数名的方法进行覆盖，有点像子类和父类的感觉。下面主要参考网上的一些资料，对mixins的实际作用做介绍：


1、方法的复用

<div id="app">

    <child></child>

    <kid></kid>

</div>


Vue.component('child',{

    template:`<h1 @click="foo">child component</h1>`,
          methods:{

        foo(){

            console.log('Child foo()'+this.msg++)
       
      }

    }

})
 

Vue.component('kid',{

    template:`<h1 @click="foo">kid component</h1>`,
    methods:{

        foo(){

            console.log('Kid foo()'+this.msg++)

        }

    }

})

在借助mixins之前，在两个不同的组件的组件中调用foo方法，需要重复定义，倘若方法比较复杂，代码将更加冗余。若借助mixins，则变得十分简单：


let mixin={

    data(){

        return{

            msg:1

        }

    },

    methods:{

        hello(){

            console.log('hello from mixin!----'+this.msg++)
        }

    }

}

var child=Vue.component('child',{
 
        template:`<h1 @click="foo">child component</h1>`, 
        mixins:[mixin]
})
Vue.component('kid',{
 
        template:`<h1 @click="foo">kid component</h1>`, 
        mixins:[mixin]
})

虽然此处，两个组件用可以通过this.msg引用mixins中定义的msg，但是，小编尝试过，两个组件引用的并不是同一个msg，而是各自创建了一个新的msg。如果在组件中定义相同的data，则此处会引用组件中的msg，而非mixins中的。




2、方法的覆盖 ?
如果在引用mixins的同时，在组件中重复定义相同的方法，则mixins中的方法会被覆盖。


var child=Vue.component('child',{

    template:`<h1 @click="foo">child component</h1>`,
    mixins:[mixin],

    methods:{

        foo(){

            console.log('Child foo()'+this.msg++)

        }

    }

})

此时，若单击h1标签，则在控制台中打印"Child foo() 1" 3、合并生命周期此时，若单击h1标签，则在控制台中打印"Child foo() 1"?


3、合并生命周期

let mixin={

    mounted(){

        console.log('mixin say hi')//先输出

    },

    data(){

        return{

            msg:1

        }

    },

    methods:{

        foo(){

            console.log('mixin foo()'+this.msg++)

        }

    }

}

let vm=new Vue({

    el:"#app",

    data:{

        msg: 2

    },
    
mounted: function(){

        console.log('app say hi')//后输出

    },

    methods:{

        foo(){

            console.log('Parent foo()'+this.msg)

        }

    }
})

--------------------- 
6、Vue中的nextTick
链接地址https://www.jianshu.com/p/a7550c0e164f
项目中在商品与评论切换处用到
Vue中的nextTick涉及到Vue中DOM的异步更新，感觉很有意思，特意了解了一下。其中关于nextTick的源码涉及到不少知识，很多不太理解，暂且根据自己的一些感悟介绍下nextTick。
一、示例
先来一个示例了解下关于Vue中的DOM更新以及nextTick的作用。
模板

<div class="app">

  <div ref="msgDiv">{{msg}}</div>

  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>

  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>

  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>

  <button @click="changeMsg">

    Change the Message

  </button>

</div>


Vue实例
new Vue({

  el: '.app',

  data: {

    msg: 'Hello Vue.',

    msg1: '',

    msg2: '',

    msg3: ''
 
 },
  methods: {

    changeMsg() {

      this.msg = "Hello world."

      this.msg1 = this.$refs.msgDiv.innerHTML

      this.$nextTick(() => {

        this.msg2 = this.$refs.msgDiv.innerHTML

      })

      this.msg3 = this.$refs.msgDiv.innerHTML

    }

  }

})


点击前







点击后







从图中可以得知：msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的（详细解释在后面）。
二、应用场景

下面了解下nextTick的主要应用的场景及原因。


在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中

在created()钩子函数执行的时候DOM
 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。
与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。


在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。

具体原因在Vue的官方文档中详细解释：


Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。
如果同一个 watcher 被多次触发，只会被推入到队列中一次。
这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。
然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。



例如，当你设置vm.someData = 'new value'，该组件不会立即重新渲染。
当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。
虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。
为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。
这样回调函数在 DOM 更新完成后就会调用。

----------------