1、fastclick
 原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
缺点: 脚本相对较大
在vue中使用???
?```js? ??// 安装? ?
 npm install fastclick -S? ? // 引入? ? 
import FastClick from 'fastclick'? ? // 使用? ? FastClick.attach(document.body);? ? ```
2、js刷新页面location.reload()用法
注意：
window.location.reload;
刷新时如果提交数据的动作，则会出现对话框！
解决
代码示例:
window.location.href=window.location.href; 
window.location.reload;
router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：在APP.js中，
https://www.jianshu.com/p/0b0222954483
// routes 配置
export default [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/:id',
    name: 'edit',
    component: Edit,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]
3.Ajax请求中的async:false/true的作用
async. 默认是true，即为异步方式，$.Ajax执行后，会继续执行ajax后面的脚本，直到服务器端返回数据后，触发$.Ajax里的success方法，这时候执行的是两个线程。若要将其设置为false，则所有的请求均为同步请求，在没有返回值之前，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。
var temp;
  $.ajax({
  
     async: false,
     type : "POST",
     url : defaultPostData.url,
     dataType : 'json',
     success : function(data) 
     {
 
      temp=data; 
   }
 
 });
 
alert(temp);
这个ajax请求为同步请求，在没有返回值之前，alert(temp)是不会执行的。

如果async设置为：true，则不会等待ajax请求返回的结果，会直接执行ajax后面的语句

4、讲讲vue路由懒加载
const tvProgram = resolve => require(['路由'], resolve);
require-ensure和require-amd的区别：     
require-amd?
说明: 同AMD规范的require函数，使用时传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数
语法:?require(dependencies: String[], [callback: function(...)])
参数?
dependencies: 模块依赖数组
callback: 回调函数

require-ensure?
说明: require.ensure在需要的时候才下载依赖的模块，当参数指定的模块都下载下来了（下载下来的模块还没执行），便执行参数指定的回调函数。require.ensure会创建一个chunk，且可以指定该chunk的名称，如果这个chunk名已经存在了，则将本次依赖的模块合并到已经存在的chunk中，最后这个chunk在webpack构建的时候会单独生成一个文件。
语法:?require.ensure(dependencies: String[], callback: function([require]), [chunkName: String])?
dependencies: 依赖的模块数组
callback: 回调函数，该函数调用时会传一个require参数
chunkName: 模块名，用于构建时生成文件时命名使用
注意点：requi.ensure的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。
--------------------- 
5、mixins混合对象的使用

对mixins的理解，有点像注册了一个vue的公共方法，可以绑定在多个组件或者多个Vue对象实例中使用。另一点，类似于在原型对象中注册方法，实例对象即组件或者Vue实例对象中，仍然可以定义相同函数名的方法进行覆盖，有点像子类和父类的感觉。下面主要参考网上的一些资料，对mixins的实际作用做介绍：


1、方法的复用

<div id="app">

    <child></child>

    <kid></kid>

</div>


Vue.component('child',{

    template:`<h1 @click="foo">child component</h1>`,
          methods:{

        foo(){

            console.log('Child foo()'+this.msg++)
       
      }

    }

})
 

Vue.component('kid',{

    template:`<h1 @click="foo">kid component</h1>`,
    methods:{

        foo(){

            console.log('Kid foo()'+this.msg++)

        }

    }

})

在借助mixins之前，在两个不同的组件的组件中调用foo方法，需要重复定义，倘若方法比较复杂，代码将更加冗余。若借助mixins，则变得十分简单：


let mixin={

    data(){

        return{

            msg:1

        }

    },

    methods:{

        hello(){

            console.log('hello from mixin!----'+this.msg++)
        }

    }

}

var child=Vue.component('child',{
 
        template:`<h1 @click="foo">child component</h1>`, 
        mixins:[mixin]
})
Vue.component('kid',{
 
        template:`<h1 @click="foo">kid component</h1>`, 
        mixins:[mixin]
})

虽然此处，两个组件用可以通过this.msg引用mixins中定义的msg，但是，小编尝试过，两个组件引用的并不是同一个msg，而是各自创建了一个新的msg。如果在组件中定义相同的data，则此处会引用组件中的msg，而非mixins中的。




2、方法的覆盖 ?
如果在引用mixins的同时，在组件中重复定义相同的方法，则mixins中的方法会被覆盖。


var child=Vue.component('child',{

    template:`<h1 @click="foo">child component</h1>`,
    mixins:[mixin],

    methods:{

        foo(){

            console.log('Child foo()'+this.msg++)

        }

    }

})

此时，若单击h1标签，则在控制台中打印"Child foo() 1" 3、合并生命周期此时，若单击h1标签，则在控制台中打印"Child foo() 1"?


3、合并生命周期

let mixin={

    mounted(){

        console.log('mixin say hi')//先输出

    },

    data(){

        return{

            msg:1

        }

    },

    methods:{

        foo(){

            console.log('mixin foo()'+this.msg++)

        }

    }

}

let vm=new Vue({

    el:"#app",

    data:{

        msg: 2

    },
    
mounted: function(){

        console.log('app say hi')//后输出

    },

    methods:{

        foo(){

            console.log('Parent foo()'+this.msg)

        }

    }
})

--------------------- 
6、Vue中的nextTick
链接地址https://www.jianshu.com/p/a7550c0e164f
项目中在商品与评论切换处用到
Vue中的nextTick涉及到Vue中DOM的异步更新，感觉很有意思，特意了解了一下。其中关于nextTick的源码涉及到不少知识，很多不太理解，暂且根据自己的一些感悟介绍下nextTick。
一、示例
先来一个示例了解下关于Vue中的DOM更新以及nextTick的作用。
模板

<div class="app">

  <div ref="msgDiv">{{msg}}</div>

  <div v-if="msg1">Message got outside $nextTick: {{msg1}}</div>

  <div v-if="msg2">Message got inside $nextTick: {{msg2}}</div>

  <div v-if="msg3">Message got outside $nextTick: {{msg3}}</div>

  <button @click="changeMsg">

    Change the Message

  </button>

</div>


Vue实例
new Vue({

  el: '.app',

  data: {

    msg: 'Hello Vue.',

    msg1: '',

    msg2: '',

    msg3: ''
 
 },
  methods: {

    changeMsg() {

      this.msg = "Hello world."

      this.msg1 = this.$refs.msgDiv.innerHTML

      this.$nextTick(() => {

        this.msg2 = this.$refs.msgDiv.innerHTML

      })

      this.msg3 = this.$refs.msgDiv.innerHTML

    }

  }

})


点击前







点击后







从图中可以得知：msg1和msg3显示的内容还是变换之前的，而msg2显示的内容是变换之后的。其根本原因是因为Vue中DOM更新是异步的（详细解释在后面）。
二、应用场景

下面了解下nextTick的主要应用的场景及原因。


在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中

在created()钩子函数执行的时候DOM
 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。
与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。


在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。

具体原因在Vue的官方文档中详细解释：


Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。
如果同一个 watcher 被多次触发，只会被推入到队列中一次。
这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。
然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
Vue 在内部尝试对异步队列使用原生的 Promise.then 和MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0)代替。



例如，当你设置vm.someData = 'new value'，该组件不会立即重新渲染。
当刷新队列时，组件会在事件循环队列清空时的下一个“tick”更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。
虽然 Vue.js 通常鼓励开发人员沿着“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。
为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用Vue.nextTick(callback) 。
这样回调函数在 DOM 更新完成后就会调用。


----------------
7、NodeJs/Vue项目中对process.env的使用
NODE_ENV获取环境变量

let env = app.get('env')

let env = process.env.NODE_ENV

//默认 NODE_ENV 为环境变量名称

//可自行在 process.env 对象下定义需要使用的变量,在项目中可以根据
//不同的 env 值设置 defaultUrl 
在webpack 打包的项目/Node JS项目中，可以安装 cross-env(跨Win/Linux平台设置 process.env值) 插件，在 package.json 文件中
设置不同的运行脚本，比如：
script:{
    "start": "node build/dev-server.js",
    "buildStag": "cross-env cross-env NODE_ENV=stag  node build/dev-server.js",
    "buildProd": "cross-env cross-env NODE_ENV=production  node build/dev-server.js",
}
//根据上述脚本即可设置不同的 NODE_ENV 值，在文件中设置值或者加载不同的设置文件，以上配置在NODE项目中可正常运行

Vue项目中使用
在使用Vue Cli构建的项目中，
需要将process.env 设置其他变量名进行使用，如：BUILD_ENV
在 package.json 的 script 字段中作如下配置：

 "scripts": {
    "start": "cross-env BUILD_ENV=dev node build/dev-server.js",
    "dev": "cross-env BUILD_ENV=dev  node build/dev-server.js",
    "build": "cross-env BUILD_ENV=dev node build/build.js",
    "buildDev": "cross-env BUILD_ENV=dev  node build/build.js",
    "buildStag": "cross-env BUILD_ENV=stag  node build/build.js",
    "buildProd": "cross-env BUILD_ENV=prod  node build/build.js",
    "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run",
    "e2e": "node test/e2e/runner.js",
    "test": "npm run unit && npm run e2e",
    "lint": "eslint --ext .js,.vue src test/unit/specs test/e2e/specs"
  },

由于搭配webpack重新设置了 process.env 的值，需要在
webpack.dev.conf.js 及 webpack.prod.conf.js 文件中：
webpack.dev.conf.js

new webpack.DefinePlugin({
    'process.env': config.dev.env,
    'process.env.BUILD_ENV': JSON.stringify(process.env.BUILD_ENV)//增加此行
})

webpack.prod.conf.js
new webpack.DefinePlugin({
    'process.env': env,
    'process.env.BUILD_ENV': JSON.stringify(process.env.BUILD_ENV)
})
即在该插件设置并暴露出 process.env 对象后，再增加
process.env.BUILD_ENV 字段并进行赋值

此时，可在前端JS文件中通过 process.env.BUILD_ENV 获得 package.json中的script获得对应值，进行其他操作，
比如，引入不同环境的配置文件，如：
在config文件夹中增加 buildConfig 文件夹，
其中新建以下3个文件：

dev.config.js 
stag.config.js 
prod.config.js,

在每个文件中采用module.exports的方式导出变量，
如：

module.exports = {

    BASE_URL: 'https://dev-api.greigreat.com',
        BASE_STATIC_URL:'https://static1.greigreat.com/'

}


在其他文件中使用

//引入环境配置文件

//process.env.BUILD_ENV 为 webpack中的DefinePlugin暴露出的环境变量

const buildConfig = require('./buildConfig/' + process.env.BUILD_ENV + '.config')

export default {

    baseUrl: buildConfig.BASE_URL,

    baseStaticUrl: buildConfig.BASE_STATIC_URL

}


则可以以对象的形式获取 buildConfig并使用


-------------------
8、vue路由嵌套，配置children嵌套路由
嵌套路由就是路由里面嵌套他的子路由，可以有自己的路由导航和路由容器（router-link、router-view），通过配置children可实现多层嵌套


//mine组件

<template>

    <div class="content">

        在mine的组件里面嵌套路由

        <router-link to="/mine/c">去到Cpage</router-link>

        <router-link to="/mine/d">去到Dpage</router-link>

        <div class="child">

            <router-view></router-view>

        </div>

    </div>

</template>
//router.js

//引入需要的组件，下是我的路径

import Vue from 'vue'

import Router from 'vue-router'

import Home from '@/components/home'

import Mine from '@/components/mine'

import Cpage from '@/page/mine/c'

import Dpage from '@/page/mine/d'

Vue.use(Router)


export default new Router({

  routes: [

    {
   
        path: '/',

        redirect: 'home'

    },

    {

      path: '/home',

      name: 'home',

      component: Home

    },

    {

      path: '/mine',

      name: 'Mine',

      component：Mine,

      children:[

        {

            path:'/',

            component:Cpage,

        },

        {

            path:'/mine/c',

            component:Cpage,

        },

        {

            path:'/mine/d',

            component:Dpage,

        }

      ]

      //children这是嵌套的部分

    },


//c.vue
<template>

    <div class="top-80">

        c.vue

        <p>这里Cpage文件</p>

    </div>
</template>


//d.vue
<template>

    <div class="top-80">

        d.vue

        <p>这里Dpage文件</p>

    </div>

</template>



嵌套路由通过配置children可实现多层嵌套，其它规则写法一样；
--------------------- 

